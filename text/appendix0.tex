
\chapter*{Answers to the Exercises}\label{Appendix:answers}

Yes, yes, you're right. We \textit{did} put in the answers to all the
exercises.  Reluctantly and against our better judgement.  Foolishly bowing to
immense pressure.  And now you've gone and found them\ldots

But just because we've done something dumb, it doesn't mean you have
to too.  Once you have seen the answer to an exercise, you'll lose
forever the chance of working it out yourself.  But you've still got
time to put things right.  So don't turn this page!  Go back and try
again!


\newpage
~
\newpage

\vspace*{7cm}

\begin{center}\large
Didn't you hear what we just said?\\
This really is your very last chance!
\end{center}

\newpage
~
\newpage

\subsection*{Answer~\ref{L1.EX1}}

\begin{enumerate}
\item \texttt{vINCENT} is an atom: it starts with a lower-case letter.
\item \texttt{Footmassage} is a variable: it starts with an upper-case letter.
\item \texttt{variable23} is an atom: it starts with a lower-case letter.
\item \texttt{Variable2000} is a variable: it starts with an uppercase letter.
\item \texttt{big\_kahuna\_burger} is an atom: it starts with a lower-case letter.
\item \texttt{'big kahuna burger'} is an atom: it is between two single quotes.
\item \texttt{big kahuna burger} is neither: variables can never
  contain spaces, and atoms cannot either --- unless the atom starts
  and ends with a single quote.
\item \texttt{'Jules'} is an atom: it is enclosed between single quotes.
\item \texttt{\_Jules} is a variable: it starts with an underscore.
\item \texttt{'\_Jules'} is an atom: it is enclosed between single quotes.
\end{enumerate}



\subsection*{Answer~\ref{L1.EX2}}

\begin{enumerate}
\item \texttt{loves(Vincent,mia)} is a complex term. Its functor is
  \texttt{loves} and its arity is 2.
\item \texttt{'loves(Vincent,mia)'} is an atom: it is enclosed between
  single quotes.
\item \texttt{Butch(boxer)} is not a term. It starts with an upper-case letter and therefore cannot be an atom or a complex term. It cannot be a variable either because variables are not supposed to contain parentheses.
\item \texttt{boxer(Butch)} is a complex term. Its functor is
  \texttt{boxer} and its arity is 1.
\item \texttt{and(big(burger),kahuna(burger))} is a complex term. Its
  functor is \texttt{and} and its arity is 2. The arguments are again complex terms.

\item \texttt{and(big(X),kahuna(X))} is a complex term. Its functor is
  \texttt{and} and its arity 2.

\item \texttt{\_and(big(X),kahuna(X))} is not a term. It starts with an underscore and can therefore not be an atom or a complex term. It cannot be a variable either because variables are not supposed to contain parentheses or commas.

\item \texttt{(Butch kills Vincent)} is not a term. It contains
  parentheses and empty spaces and therefore can neither be an atom nor a
  variable. It doesn't have the right format for a complex term either; in
  particular, it has no functor.

\item \texttt{kills(Butch Vincent)} is not a term. However, adding a comma between Butch and Vincent would make it into a complex term.

\item \texttt{kills(Butch,Vincent} is not a term. However, adding a closing parenthesis at the end would make it into a complex term.
\end{enumerate}





\subsection*{Answer~\ref{L1.EX3}} 

There are three facts and four rules in this knowledge base. This means that
there are seven clauses. The heads of the rules are
\texttt{person(X)}, \texttt{loves(X,Y)}, and \texttt{father(Y,Z)}
(everything on the left-hand side of the rules), the goals are
\texttt{man(X)}, \texttt{woman(X)}, \texttt{father(X,Y)},
\texttt{man(Y)}, \texttt{son(Z,Y)}, and \texttt{daughter(Z,Y)}
(everything on the right hand side of the rules). This knowledge base
defines five predicates, namely \texttt{woman/1}, \texttt{man/1},
\texttt{person/1}, \texttt{loves/2}, and \texttt{father/2}.




\subsection*{Answer~\ref{L1.EX4}}

Here is an example of what your answers could look like. They, of
course, don't have to look \LPNemph{exactly} like that. For example,
the first fact could also be §killer('Butch')§ or §killer(b)§ or even
$k(50)$, if you decide to represent Butch by the number §50§ and the
property of being a killer by the predicate §k/1§.

\begin{enumerate}

\item 
\begin{LPNcodedisplay}
killer(butch).
\end{LPNcodedisplay}

\item 
\begin{LPNcodedisplay}
married(mia, marsellus).
\end{LPNcodedisplay}

\item 
\begin{LPNcodedisplay}
dead(zed).
\end{LPNcodedisplay}

\item 
\begin{LPNcodedisplay}
kill(marsellus,X):- give(X,mia,Y), footmassage(Y).
\end{LPNcodedisplay}

\item 
\begin{LPNcodedisplay}
love(mia,X):- good_dancer(X).
\end{LPNcodedisplay}

\item 
\begin{LPNcodedisplay}
eat(jules,X):- nutritious(X).
eat(jules,X):- tasty(X).
\end{LPNcodedisplay}

\end{enumerate}


\subsection*{Answer~\ref{L1.EX5}} 

\begin{enumerate}

\item 
\begin{LPNcodedisplay}
?- wizard(ron).
yes
\end{LPNcodedisplay}

\item
\begin{LPNcodedisplay}
?- witch(ron).
no
\end{LPNcodedisplay}
        or
\begin{LPNcodedisplay}
ERROR: Undefined procedure: witch/1
\end{LPNcodedisplay}

\item
\begin{LPNcodedisplay}
?- wizard(hermione).
no
\end{LPNcodedisplay}

\item
\begin{LPNcodedisplay}
?- witch(hermione).
no
\end{LPNcodedisplay}
        or
\begin{LPNcodedisplay}         
ERROR: Undefined procedure: witch/1
\end{LPNcodedisplay}

\item
\begin{LPNcodedisplay}
?- wizard(harry).
yes
\end{LPNcodedisplay}

\item
\begin{LPNcodedisplay}
?- wizard(Y).
Y = ron ;
Y = harry ;
no
\end{LPNcodedisplay}

\item
\begin{LPNcodedisplay}
?- witch(Y).
no
\end{LPNcodedisplay}         
        or
\begin{LPNcodedisplay}         
ERROR: Undefined procedure: witch/1
\end{LPNcodedisplay}

\end{enumerate}





\subsection*{Answer~\ref{L2.EX1}} 

\begin{enumerate}
\item \texttt{bread = bread} unifies.
\item \texttt{'Bread' = bread} doesn't unify.
\item \texttt{'bread' = bread} unifies.
\item \texttt{Bread = bread} unifies; the variable \texttt{Bread} gets instantiated with the atom \texttt{bread}.
\item \texttt{bread = sausage} doesn't unify.
\item \texttt{food(bread) = bread} doesn't unify.
\item \texttt{food(bread) = X} unifies; \texttt{X} gets instantiated with \texttt{food(bread)}.

\item \texttt{food(X) = food(bread)} unifies; \texttt{X} gets instantiated with \texttt{bread}.

\item \texttt{food(bread,X) = food(Y,sausage)} unifies; \texttt{X}
  gets instantiated with \texttt{sausage} 
  and \texttt{Y} gets instantiated with \texttt{bread}.

\item \texttt{food(bread,X,beer) = food(Y,sausage,X)} doesn't unify; \texttt{X} cannot be instantiated with \texttt{sausage} as well as \texttt{beer}.

\item \texttt{food(bread,X,beer) = food(Y,kahuna\_burger)} doesn't unify; 
the functors are of different arity.

\item \texttt{food(X) = X} is trickier. According to the basic
definition of unification given in the text, these two terms do not
unify, as no matter what (finite) term we instantiate \texttt{X} to,
the two sides won't be identical.  However (as we mentioned in the
text) modern Prolog interpreters will detect that there is a problem
here and will instantiate \texttt{X} with the `infinite term'
\texttt{food(food(food(...)))}, and report that unification succeeds.
In short, there is no `correct' answer to this question; it's
essentially a matter of convention. The important point is to
understand why such unifications need to be handled with care.

\item \texttt{meal(food(bread),drink(beer)) = meal(X,Y)} unifies; \texttt{X} gets instantiated with \texttt{food(bread)} and \texttt{Y} with \texttt{drink(beer)}.
\item \texttt{meal(food(bread),X) = meal(X,drink(beer))} doesn't unify; \texttt{X} cannot get instantiated twice with different things.
\end{enumerate}




\subsection*{Answer~\ref{L2.EX2}} 
\begin{enumerate}

\item 
\begin{LPNcodedisplay}         
?- magic(house_elf).  no
\end{LPNcodedisplay}

\item
\begin{LPNcodedisplay}         
?- wizard(harry).
no
\end{LPNcodedisplay}         
or
\begin{LPNcodedisplay}         
ERROR: undefined procedure wizard/1
\end{LPNcodedisplay}

\item
\begin{LPNcodedisplay}         
?- magic(wizard).
no
\end{LPNcodedisplay}

\item
\begin{LPNcodedisplay}         
?- magic('McGonagall').
yes
\end{LPNcodedisplay}

\item
\begin{LPNcodedisplay}         
?- magic(Hermione).
Hermione = dobby ;
Hermione = hermione ;
Hermione = 'McGonagall' ;
Hermione = rita_skeeter ;
no
\end{LPNcodedisplay}

The search tree for the last query is:
\begin{LPNcodedisplay}         
              ?- magic(Hermione)
              /     |        \
Hermione=_G65  Hermione=_G76  Hermione=_G87
           /        |          \
?- house_elf(_G65) |           \
          |         |            \
  _G65=dobby  ?- wizard(_G76)    \
          |         |              |
          |         |      ?- witch(_G87)
      success     fail     /      |    \
                          /        |     \
                 _G87=hermione    |      \
                          |        |       \
                          | _G87='McGonag' \
                          |       |          \
                          |       |  _G87=r_skeeter
                          |       |          |
                      success  success    success
\end{LPNcodedisplay}                                 
\end{enumerate}


\subsection*{Answer~\ref{L2.EX3}} 

\begin{LPNcodedisplay}         
?- sentence(W1,W2,W3,W4,W5).
W1 = a, 
W2 = criminal, 
W3 = eats, 
W4 = a, 
W5 = criminal ;

W1 = a, 
W2 = criminal, 
W3 = eats, 
W4 = a, 
W5 = 'big kahuna burger' ;

W1 = a, 
W2 = criminal, 
W3 = eats, 
W4 = every, 
W5 = criminal ;

W1 = a, 
W2 = criminal, 
W3 = eats, 
W4 = every, 
W5 = 'big kahuna burger' ;

W1 = a, 
W2 = criminal, 
W3 = likes, 
W4 = a, 
W5 = criminal ;

W1 = a, 
W2 = criminal, 
W3 = likes, 
W4 = a, 
W5 = 'big kahuna burger' ;

W1 = a, 
W2 = criminal, 
W3 = likes, 
W4 = every, 
W5 = criminal ;

W1 = a, 
W2 = criminal, 
W3 = likes, 
W4 = every, 
W5 = 'big kahuna burger' ;

W1 = a, 
W2 = 'big kahuna burger', 
W3 = eats, 
W4 = a, 
W5 = criminal ;

        .
        .
        .

W1 = every, 
W2 = 'big kahuna burger', 
W3 = likes, 
W4 = every, 
W5 = 'big kahuna burger' ;
no
\end{LPNcodedisplay}


\subsection*{Answer~\ref{L2.EX4}} 

\begin{LPNcodedisplay}         
crossword(V1,V2,V3,H1,H2,H3):-
   word(V1,_,A,_,B,_,C,_),
   word(V2,_,D,_,E,_,F,_),
   word(V3,_,G,_,H,_,I,_),
   word(H1,_,A,_,D,_,G,_),
   word(H2,_,B,_,E,_,H,_),
   word(H3,_,C,_,F,_,I,_).
\end{LPNcodedisplay}

\subsection*{Answer~\ref{L3.EX5}} 

No, it's not a good idea to reformulate \texttt{descend/2} in that
way: it will get in an infinite loop for certain queries. For
example, if one queries \texttt{?- descend(rose,X)}, the first
clause will fail, but the second clause applies. But the second
clause tries to find a solution for \texttt{?- descend(rose,Z)},
and so on.


\subsection*{Answer~\ref{L3.EX1}} 

\begin{LPNcodedisplay}         
directlyIn(irina,natasha).
directlyIn(natasha,olga).
directlyIn(olga,katarina).

in(X,Y):- directlyIn(X,Y).
in(X,Y):- directlyIn(X,Z), in(Z,Y).
\end{LPNcodedisplay}



\subsection*{Answer~\ref{L3.EX3}} 

\begin{LPNcodedisplay}         
travelFromTo(X,Y):- 
   directTrain(X,Y).

travelFromTo(X,Y):-  
   directTrain(X,Z),
   travelFromTo(Z,Y).
\end{LPNcodedisplay}

%There is no solution to this exercise (using only the things that we have
%learned up to now), which will not end up in a loop sooner or later. Carefully
%check your solution to see when this happens. Also, try to travel between
%cities that are not mentioned in the database (for example, try using Paris and
%Madrid). Prolog should answer `no', but it will most probably end up in a loop
%instead.

%A way out of the problem would be to keep track of the cities we have
%already passed and to disallow passing the same city twice. But to
%implement this solution you need to know about lists and about
%negation. We will come back to this exercise in Chapter~10.



\subsection*{Answer~\ref{L3.EX2}}

\begin{LPNcodedisplay}         
greater_than(succ(X),0).
greater_than(succ(X),succ(Y)):- greater_than(X,Y).
\end{LPNcodedisplay}


\subsection*{Answer~\ref{L3.EX4}} 

\begin{LPNcodedisplay}         
swap(leaf(X),leaf(X)).
swap(tree(B1,B2),tree(B2Swapped,B1Swapped)):-
   swap(B1,B1Swapped),
   swap(B2,B2Swapped).
\end{LPNcodedisplay}




\subsection*{Answer~\ref{L4.EX1}} 

\begin{enumerate}
\item \begin{LPNcodedisplay}         
?- [a,b,c,d] = [a,[b,c,d]].
No
\end{LPNcodedisplay}         
(The first list has four elements; the second only two.)

\item \begin{LPNcodedisplay}         
?- [a,b,c,d] = [a|[b,c,d]].
Yes
\end{LPNcodedisplay}         
         
\item \begin{LPNcodedisplay}         
?- [a,b,c,d] = [a,b,[c,d]].
No
\end{LPNcodedisplay}         
         
\item \begin{LPNcodedisplay}         
?- [a,b,c,d] = [a,b|[c,d]].
Yes
\end{LPNcodedisplay}         
         
\item \begin{LPNcodedisplay}         
?- [a,b,c,d] = [a,b,c,[d]].
No
\end{LPNcodedisplay}         
         
\item \begin{LPNcodedisplay}         
?- [a,b,c,d] = [a,b,c|[d]].
Yes
\end{LPNcodedisplay}         
         
\item \begin{LPNcodedisplay}         
?- [a,b,c,d] = [a,b,c,d,[]].
No
\end{LPNcodedisplay}         
         
\item \begin{LPNcodedisplay}         
?- [a,b,c,d] = [a,b,c,d|[]].
Yes
\end{LPNcodedisplay}         
         
\item \begin{LPNcodedisplay}         
?- [] = _.
Yes
\end{LPNcodedisplay}         
         
\item \begin{LPNcodedisplay}         
?- [] = [_].
No
\end{LPNcodedisplay}         
(The first list is empty; the second list has one element.)
         
\item \begin{LPNcodedisplay}         
?- [] = [_|[]].
No
\end{LPNcodedisplay}         
(The first list is empty; the second list has one element.)

\end{enumerate}


\subsection*{Answer~\ref{L4.EX1.2}}

\begin{enumerate}
\item \texttt{[1|[2,3,4]]} is correct. The list has four elements.

\item \texttt{[1,2,3|[]]} is correct. The list has three elements.

\item \texttt{[1|2,3,4]} is not correct. The tail, that is,
what's right of \texttt{|}, has to be a list (as in the first example) but it's
not.


\item \texttt{[1|[2|[3|[4]]]]} is correct. The list has four elements.

\item \texttt{[1,2,3,4|[]]} is correct. The list has four elements.

\item \texttt{[[]|[]]} is correct. The list has one element, namely the empty list.

\item \texttt{[[1,2]|4]} is not correct. The tail is not a list.

\item \texttt{[[1,2],[3,4]|[5,6,7]]} is correct. The list has five elements.


\end{enumerate}



\subsection*{Answer~\ref{L6.EX3a}} 
\begin{LPNcodedisplay}         
second(X,[_,X|_]).
\end{LPNcodedisplay}         

\subsection*{Answer~\ref{L6.EX3b}} 
\begin{LPNcodedisplay}         
swap12([H1,H2|T],[H2,H1|T]).
\end{LPNcodedisplay}         


\subsection*{Answer~\ref{L4.EX2}}

The base clause: the input list is empty. There is nothing to translate, so the
output list is empty as well.
         
\begin{LPNcodedisplay}         
listtran([],[]).  
\end{LPNcodedisplay}         
         
The recursive clause: we translate the head \texttt{G} of the input list using
the predicate \texttt{tran/2}. The result is \texttt{E} and becomes the head of
the output list. Then we recursively translate the rest of the input. The
result becomes the rest of the output.
         
\begin{LPNcodedisplay}         
listtran([G|GT],[E|ET]):- 
   tran(G,E), 
   listtran(GT,ET).
\end{LPNcodedisplay}         


\subsection*{Answer~\ref{L4.EX3}} 

The base clause: the input list is empty. So there is nothing to write to the
output list. So that is empty as well.
         
\begin{LPNcodedisplay}         
twice([],[]).  
\end{LPNcodedisplay}                  

The recursive clause: the first two elements of the output list are
both identical to the head of the input list. The recursive call
simply produces the tail of the output list from the tail of the input
list.
         
\begin{LPNcodedisplay}         
twice([H|TIn],[H,H|TOut]):- 
   twice(TIn, TOut).
\end{LPNcodedisplay}         


\subsection*{Answer~\ref{L4.EX4}} 
\begin{LPNcodedisplay}         
?- member(a,[c,b,a,y]).
           |
?- member(a,[b,a,y])
           |
 ?- member(a,[a,y])
           |
        success
\end{LPNcodedisplay}         

\begin{LPNcodedisplay}         
?- member(x,[a,b,c]).
         |
?- member(x,[b,c]).
         |
 ?- member(x,[c]).
         |
  ?- member(x,[]).
         |
        fail
\end{LPNcodedisplay}         

\begin{LPNcodedisplay}         
?- member(X,[a,b,c]).
   /          \
X=a            X=_G65
  |            |
success   ?-member(_G65,[b,c]).
          /                 \
     _G65=b    ?- member(_G65,[c])
          |                  |
      success           _G65=c
                             |
                          success
\end{LPNcodedisplay}         


\subsection*{Answer~\ref{L5.EX1}} 

\begin{enumerate}
\item Prolog answers: \texttt{X = 3*4}. Variable \texttt{X} is instantiated
with the complex term \texttt{3*4}.
\item Prolog answers: \texttt{X = 12}.
\item Prolog answers: ERROR: Arguments are not sufficiently instantiated.
\item Prolog answers: \texttt{X = Y}.
\item Prolog answers: yes.
\item Prolog answers: yes.
\item Prolog answers: ERROR: Arguments are not sufficiently instantiated.
\item Prolog answers: \texttt{X = 3}.

\item Prolog answers: no. Prolog evaluates the arithmetic expression
to the right of \texttt{is/2}. Then it tries to unify the result with
the term to the left of \texttt{is/2}. This fails as the number \texttt{3} does
not unify the complex term \texttt{1+2}.

\item Prolog answers: \texttt{X = 3}.

\item Prolog answers: yes. \texttt{3+2} and \texttt{+(3,2)} are two
ways of writing the same term.

\item Prolog answers: yes.
\item Prolog answers: yes.
\item Prolog answers: yes.
\item Prolog answers: no.
\item Prolog answers: yes.
\end{enumerate}



\subsection*{Answer~\ref{L5.EX2}} 
\begin{LPNcodedisplay}         
increment(X,Y):- 
   Y is X + 1.

sum(X,Y,Z):- 
   Z is X + Y.
\end{LPNcodedisplay}         

\subsection*{Answer~\ref{L5.EX3}}
\begin{LPNcodedisplay}         
addone([],[]).

addone([H|T],[H1|T1]):-
   H1 is H + 1,
   addone(T,T1).
\end{LPNcodedisplay}         






\subsection*{Answer~\ref{L6.EX1}} 
\begin{LPNcodedisplay}         
doubled(L):- 
   append(L1,L1,L).
\end{LPNcodedisplay}         



\subsection*{Answer~\ref{L6.EX2}} 

A solution using \texttt{rev/2}:

\begin{LPNcodedisplay}         
palindrome(L):- 
   rev(L,L).
\end{LPNcodedisplay}         

\noindent A solution that is not using a reverse predicate:

\begin{LPNcodedisplay}         
palindrome(L):- 
   check_palindrome(L,[]).
         
check_palindrome(L,L).

check_palindrome([_|L],L).

check_palindrome([H|T],LPal):- 
   check_palindrome(T,[H|LPal]).
\end{LPNcodedisplay}         


\subsection*{Answer~\ref{L6.EX3c}} 
\begin{LPNcodedisplay}         
toptail([H|TInList],OutList):-
   append(OutList,[_],TInList).
\end{LPNcodedisplay}         

\subsection*{Answer~\ref{L6.EX3d}} 
A solution using \texttt{reverse/2}:

\begin{LPNcodedisplay}         
last(L,X):-
   reverse(L,[X|_]).
\end{LPNcodedisplay}         

\noindent An alternative solution:

\begin{LPNcodedisplay}         
last([X],X).

last([_|L],X):-
   last(L,X).
\end{LPNcodedisplay}         


\subsection*{Answer~\ref{L6.EX3e}} 
A solution using \texttt{append/3}:
\begin{LPNcodedisplay}         
swapfl([H1|T1],[H2|T2]):-
   append(Middle,[H2],T1),
   append(Middle,[H1],T2).
\end{LPNcodedisplay}         

\noindent An alternative solution:

\begin{LPNcodedisplay}         
swapfl([First,Last],[Last,First]).

swapfl([First,Next|L1],[Last,Next|L2]):-  
   swapfl([First|L1],[Last|L2]).
\end{LPNcodedisplay}         





\subsection*{Answer~\ref{L6.EX4}} 

In this solution the street is represented as list of three houses.
A house is represented as a 3-place (colour, nationality, pet) complex
term. With the help of \texttt{member/2} and \texttt{sublist/2} we
check the constraints of the puzzle.

\begin{LPNcodedisplay}         
zebra(N) :-
 Street = [House1,House2,House3],
 member(house(red,_,_),Street),
 member(house(blue,_,_),Street),
 member(house(green,_,_),Street),
 member(house(red,english,_),Street),
 member(house(_,spanish,jaguar),Street),        
 sublist([house(_,_,snail),house(_,japanese,_)],Street),
 sublist([house(blue,_,_),house(_,_,snail)],Street),
 member(house(_,N,zebra),Street).
\end{LPNcodedisplay}         



\subsection*{Answer~\ref{L7.EX1}} 

The internal representation of the DCG rules that Prolog will work with:

\begin{LPNcodedisplay}         
s(A,B) :- foo(A,C), bar(C,D), wiggle(D,B).
foo([choo|A],A).
foo(A,B) :- foo(A,C), foo(C,B).
bar(A,B) :- mar(A,C), zar(C,B).
mar(A,B) :- me(A,C), my(C,B).
me([i|A],A).
my([am|A],A).
zar(A,B) :- blar(A,C), car(C,B),
blar([a|A],A).
car([train|A],A).
wiggle([toot|A],A).
wiggle(A,B) :- wiggle(A,C), wiggle(C,B).
\end{LPNcodedisplay}         

The first three sentences that Prolog will generate:
\begin{enumerate}
\item         choo i am a train toot
\item           choo i am a train toot toot
\item          choo i am a train toot toot toot
\end{enumerate}

\subsection*{Answer~\ref{L7.EX2}} 

\begin{LPNcodedisplay}         
s --> [a,b].
s --> a, s, b.
a --> [a].
b --> [b].
\end{LPNcodedisplay}         

\subsection*{Answer~\ref{L7.EX3}} 

\begin{LPNcodedisplay}         
s --> [].
s --> a, s, b.
a --> [a].
b --> [b,b].
\end{LPNcodedisplay}         


\subsection*{Answer~\ref{L8.EX1}} 

\begin{LPNcodedisplay}
s --> np(Num),vp(Num).

np(Num) --> det(Num),n(Num).

vp(Num) --> v(Num),np(_).
vp(Num) --> v(Num).

det(_) --> [the].
det(sg) --> [a].

n(sg) --> [woman].
n(pl) --> [women].
n(sg) --> [man].
n(pl) --> [men].
n(sg) --> [apple].
n(pl) --> [apples].
n(sg) --> [pear].
n(pl) --> [pears].

v(sg) --> [eats].
v(pl) --> [eat].
\end{LPNcodedisplay}


\subsection*{Answer~\ref{L8.EX2}} 
\begin{LPNcodedisplay}
kanga(A,B,C,D,E):-
   roo(A,B,D,F),
   jumps(C,C,F,G),
   marsupial(A,B,C),
   E=G.
\end{LPNcodedisplay}



\subsection*{Answer~\ref{L9.EX1}}
\begin{enumerate}
\item The query \texttt{?- 12 is 2*6.} succeeds.

\item The query §?- 14 =\= 2*6.§ succeeds.

\item The query \texttt{?- 14 = 2*7.} fails.

\item The query \texttt{?- 14 == 2*7.} fails.

\item The query §?- 14 \== 2*7.§ succeeds.

\item The query \texttt{?- 14 =:= 2*7.} succeeds.

\item The query \texttt{?- [1,2,3|[d,e]] == [1,2,3,d,e].} succeeds.

\item The query \texttt{?- 2+3 == 3+2.} fails.

\item The query \texttt{?- 2+3 =:= 3+2.} succeeds.

\item The query §?- 7-2 =\= 9-2.§ succeeds.

\item The query §?- p == 'p'.§ succeeds.

\item The query §?- p =\= 'p'.§ yields an error.

\item The query \texttt{?- vincent == VAR.} fails.

\item The query \texttt{?- vincent=VAR, VAR==vincent.} succeeds.
\end{enumerate}


\subsection*{Answer~\ref{L9.EX2}}
\begin{enumerate}
\item The query \texttt{?- .(a,.(b,.(c,[]))) = [a,b,c].} succeeds.

\item The query \texttt{?- .(a,.(b,.(c,[]))) = [a,b|[c]].} succeeds.

\item The query \texttt{?- .(.(a,[]),.(.(b,[]),.(.(c,[]),[])))=X.} succeeds and and X = [[a],[b],[c]].

\item The query \texttt{?- .(a,.(b,.(.(c,[]),[]))) = [a,b|[c]].} fails.
\end{enumerate}

\subsection*{Answer~\ref{L9.EX3}}
\begin{LPNcodedisplay}
termtype(Term,variable):- 
   var(Term).

termtype(Term,atom):- 
   atom(Term).

termtype(Term,number):- 
   number(Term).

termtype(Term,constant):- 
   atomic(Term).

termtype(Term,simple_term):- 
   atomic(Term).

termtype(Term,simple_term):- 
   var(Term).

termtype(Term,complex_term):- 
   nonvar(Term),
   functor(Term,_,Arity), 
   Arity > 0.

termtype(Term,term):- 
   termtype(Term,simple_term).

termtype(Term,term):- 
   termtype(Term,complex_term).
\end{LPNcodedisplay}


\subsection*{Answer~\ref{L9.EX4}}

First, a solution that doesn't use univ:
\begin{LPNcodedisplay}
groundterm(Term):- 
   atomic(Term).

groundterm(Term):-
   nonvar(Term),
   functor(Term,_,Arity),
   groundterms(Term,Arity).

groundterms(_,0).

groundterms(ComplexTerm,Arg):-
   Arg > 0,
   arg(Arg,ComplexTerm,Term),
   groundterm(Term),
   NextArg is Arg - 1,
   groundterms(ComplexTerm,NextArg).
\end{LPNcodedisplay}

And here is a solution that does use univ:
\begin{LPNcodedisplay}
groundterm(Term) :-
        atomic(Term).
groundterm(Term) :-
        nonvar(Term),
        Term =.. [_|Args],
        groundterms(Args).

groundterms([]).
groundterms([H|T]) :-
        groundterm(H),
        groundterms(T).
\end{LPNcodedisplay}

\subsection*{Answer~\ref{L9.EX5}}
Given these operator definitions,
\begin{enumerate}
\item \texttt{X is\_a witch} corresponds to the Prolog term \texttt{is\_a(X,witch)};
\item \texttt{harry and ron and hermione are friends} corresponds to the Prolog term \texttt{are(and(harry,and(ron,hermione)),friends)};
\item \texttt{harry is\_a wizard and likes quidditch} is not a Prolog term;
\item \texttt{dumbledore is\_a famous wizard} corresponds to the Prolog term \texttt{isa\_a(dumbledore,famous(wizard))}.
\end{enumerate}



\subsection*{Answer~\ref{L10.EX1}}
\begin{LPNcodedisplay}
?- p(X).
X = 1 ;
X = 2 ;
No

?- p(X), p(Y).
X = 1
Y = 1 ;
X = 1
Y = 2 ;
X = 2
Y = 1 ;
X = 2
Y = 2 ;
No

?- p(X), !, p(Y).
X = 1
Y = 1 ;
X = 1
Y = 2 ;
No
\end{LPNcodedisplay}


\subsection*{Answer~\ref{L10.EX2}}
The original program tells whether a number is positive, zero, or
negative. It does that using three clauses. But if one of the three
clauses succeeds in solving a goal, the others do not apply.  Hence we
can add green cuts:

\begin{LPNcodedisplay}
class(Number,positive):- Number > 0, !.
class(0,zero):- !.
class(Number,negative):- Number < 0, !.
\end{LPNcodedisplay}


\subsection*{Answer~\ref{L10.EX3}}

A version of \texttt{split/3} without using the cut:

\begin{LPNcodedisplay}
split([],[],[]).

split([Number|L],[X|Pos],Neg):-
   Number >= 0,
   split(L,Pos,Neg).

split([Number|L],Pos,[X|Neg]):-
   Number < 0,
   split(L,Pos,Neg).
\end{LPNcodedisplay}


A version of \texttt{split/3} using the cut:

\begin{LPNcodedisplay}
split([],[],[]):- !.

split([Number|L],[X|Pos],Neg):-
   Number > 0, !,
   split(L,Pos,Neg).

split([Number|L],[X|Pos],Neg):-
   Number = 0, !,
   split(L,Pos,Neg).

split([Number|L],Pos,[X|Neg]):-
   Number < 0, !,
   split(L,Pos,Neg).
\end{LPNcodedisplay}


\subsection*{Answer~\ref{L10.EX4}}  
\begin{LPNcodedisplay}
directTrain(saarbruecken,dudweiler).
directTrain(forbach,saarbruecken).
directTrain(freyming,forbach).
directTrain(stAvold,freyming).
directTrain(fahlquemont,stAvold).
directTrain(metz,fahlquemont).
directTrain(nancy,metz).

trainConnection(A,B):- directTrain(A,B).
trainConnection(A,B):- directTrain(B,A).

route(A,B,Route):-
   route(B,A,[B],Route).

route(A,B,Route,[B|Route]):-
   trainConnection(A,B),
   \+ member(B,Route).

route(A,C,SoFar,Route):-
   trainConnection(A,B),
   \+ member(B,SoFar),
   route(B,C,[B|SoFar],Route).
\end{LPNcodedisplay}


\subsection*{Answer~\ref{L11.EX1}}  

After the first query the database contains:

\begin{LPNcodedisplay}
q(foo,blug).
q(a,b).
q(1,2).
\end{LPNcodedisplay}
\noindent  
After the second command the database contains:

\begin{LPNcodedisplay}
q(foo,blug).
q(a,b).
p(X):- h(X).
\end{LPNcodedisplay}
\noindent  
After the third command the database contains:

\begin{LPNcodedisplay}
p(X):- h(X).
\end{LPNcodedisplay}



\subsection*{Answer~\ref{L11.EX2}}  

\begin{enumerate}
\item \begin{LPNcodedisplay}
List = [blug,blag,blig] ;
No
\end{LPNcodedisplay}

\item \begin{LPNcodedisplay}
List = [blob,dang] ;
No
\end{LPNcodedisplay}

\item \begin{LPNcodedisplay}
List = [blob,blob,blob,blaf,dang,dang,flab] ;
No
\end{LPNcodedisplay}

\item \begin{LPNcodedisplay}
List = [blob] ;
Y = blag
List = [blob,blaf] ;
Y = dong
List = [dang] ;
Y = blug
List = [blob,dang] ;
Y = blob
List = [flab] ;
No
\end{LPNcodedisplay}

\item \begin{LPNcodedisplay}
List = [blaf,blob,dang,flab] ;
No
\end{LPNcodedisplay}
\end{enumerate}



\subsection*{Answer~\ref{L11.EX3}}  

\begin{LPNcodedisplay}
:- dynamic sigmares/2.

sigmares(0,0).

sigma(Number,Sum):-
   sigmares(Number,Sum).

sigma(Number,Total):-
   Number > 0,
   \+ sigmares(Number,Total),
   NewNumber is Number - 1,
   sigma(NewNumber,SubTotal),
   Total is SubTotal + Number,
   assert(sigmares(Number,Total)).
\end{LPNcodedisplay}
  


\subsection*{Answer~\ref{L12.EX1}}  

\begin{LPNcodedisplay}
piece_of_code:-
   open('hogwart.houses',write,Stream),
   tab(Stream,6), 
   write(Stream,gryffindor), 
   nl(Stream),
   write(Stream,hufflepuf), 
   tab(Stream,6), 
   write(Stream,ravenclaw), 
   nl(Stream),
   tab(Stream,6), 
   write(Stream,slytherin), 
   nl(Stream),
   close(Stream).
\end{LPNcodedisplay}


\subsection*{Answer~\ref{L12.EX2}}  

\begin{LPNcodedisplay}
:- dynamic word/2.

readWord(Stream,W,Status):-
   get_code(Stream,Char),
   checkCharAndReadRest(Char,Chars,Stream,Status),
   atom_codes(W,Chars).

checkCharAndReadRest(10,[],_,ok):- !.  
checkCharAndReadRest(32,[],_,ok):- !.  
checkCharAndReadRest(-1,[],_,eof):- !.  
checkCharAndReadRest(end_of_file,[],_,eof):- !.
checkCharAndReadRest(Char,[Char|Chars],Stream,Status):-
   get_code(Stream,NextChar),
   checkCharAndReadRest(NextChar,Chars,Stream,Status).

read_text(File):-
   open(File,read,Stream),
   read_words(Stream,ok),
   close(Stream).

read_words(_,eof).

read_words(Stream,PrevStatus):-
   \+ PrevStatus = eof,
   readWord(Stream,Word,Status),
   addWord(Word),
   read_words(Stream,Status).

addWord(Word):-
   word(Word,Freq), !,
   retract( word(Word,Freq) ),
   NewFreq is Freq + 1, 
   assert( word(Word,NewFreq) ).

addWord(Word):-
   assert( word(Word,1) ).
\end{LPNcodedisplay}
